<!DOCTYPE html>
<html>

<head lang="en">
    <meta charset="UTF-8">
    <title>Homework 4 - Tasks 1a and 1b</title>

    <!-- ADD Libraries-->
    <script src="http://d3js.org/d3.v3.js" charset="utf-8"></script>
    <script src="http://code.jquery.com/jquery-2.1.4.js" charset="utf-8"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>

    <script src="libs/tester.js"></script>

    <!--Stylesheets-->
    <link rel="stylesheet" type="text/css" href="libs/bootstrap/css/bootstrap.min.css">

    <!-- Get a nice font-->
    <link href='http://fonts.googleapis.com/css?family=PT+Sans:400,700' rel='stylesheet' type='text/css'>
</head>

<body>
    <div class="container">
        <h1>Test Data Asynchronous Loading (1a) and  Aggregation (1b)</h1>

        <p>See the results of the tests below. Be aware that passing the test only once might not guarantee a correct solution (especially for Task 1a).</p>

        <div class="panel panel-warning" id="t1a">
            <div class="panel-heading ">Task 1a</div>
            <div class="panel-body">
                Load <code>data/MYWorld_fields.json</code> and <code>data/perDayData.json</code> then call <code>allLoaded(data, metaData);</code>
            </div>
        </div>

        <div class="panel panel-warning" id="t1b">
            <div class="panel-heading">Task 1b</div>
            <div class="panel-body">
                Call <code>aggregateCountsForRange(from, to)</code> for the the range of January 1, 2013 to January 31, 2013.
            </div>
        </div>
    </div>

    <script>
        (function () {
            var allData = [];
            var metaData = {};
            var dateFormatter = d3.time.format("%Y-%m-%d");

            // Here I use Promise, which is already in ES6
            var loadMetaData = new Promise(function(resolve, reject) {
                d3.json("data/MYWorld_fields.json", function(error, json) {
                    if (error) reject(error);
                    else resolve(json);
                });
            });

            var loadAllData = new Promise(function(resolve, reject) {
                d3.json("data/perDayData.json", function(error, json) {
                    if (error) reject(error);
                    else resolve(json);
                });
            });

            Promise.all([loadAllData, loadMetaData]).then(function(results) {
                allLoaded(null, results[0], results[1]);
            });

            var aggregateCountsForRange = function (from, to) {
                // ******* TASK 1b *******
                // Count the number of elements in allData that match the given time range
                var count = allData.filter(function(each) {
                    return each.time >= from && each.time <= to;
                }).map(function(each) {
                    return each.count;
                }).reduce(function(x, y) {
                    return x + y;
                });
                tester.checkCount(count);
            };

            function allLoaded(error, perDay, meta) {
                metaData = meta;
                allData = perDay.map(function (d) {
                    var res = {
                        time: dateFormatter.parse(d.day),
                        count: +d["count(*)"]
                    };
                    return res;
                })

                tester.allLoaded(allData, metaData);
                // This calls the aggregate function as soon as all your data is loaded
                aggregateCountsForRange(dateFormatter.parse("2013-01-01"), dateFormatter.parse("2013-01-31"))
            }

        })()
    </script>
</body>
</html>
